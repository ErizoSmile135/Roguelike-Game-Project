{"version":3,"sources":["file:///C:/GameECSProject/assets/scripts/systems/RenderSystem.ts"],"names":["RenderSystem","instantiate","Vec3","Node","tween","PlayerTag","PrefabNames","EnemyTag","TileTag","Position","ViewComponent","SceneController","eventBus","Trap","constructor","em","prefabs","gameRoot","tilesLayer","entityLayer","playerLayer","tileSize","stepDuration","on","onMovePath","bind","getPrefabName","entityId","hasComponent","Player","Enemy","Tile","render","entities","getEntityWithComponent","prefabName","id","position","getComponent","view","console","log","addComponent","prefab","node","setPosition","x","y","EventType","TOUCH_END","_instance","onTileTapped","addChild","entity","path","length","z","getPosition","animateStep","idx","emit","pos","enemies","filter","eid","p","attacker","target","step","to","call","trapIds","tid","trap","start","update","dt"],"mappings":"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","sourcesContent":["import { instantiate, Prefab, Vec3, Node, UITransform, tween } from \"cc\";\nimport { EntityManager } from \"../core/EntityManager\";\nimport { PlayerTag } from \"../components/Tag/PlayerTag\";\nimport { PrefabNames } from \"../data/consts\";\nimport { EnemyTag } from \"../components/Tag/EnemyTag\";\nimport { TileTag } from \"../components/Tag/TileTag\";\nimport { Position } from \"../components/Position\";\nimport { ViewComponent } from \"../components/core/ViewComponent\";\nimport { SceneController } from \"../core/SceneController\";\nimport { PrefabType } from \"../data/types\";\nimport { eventBus } from \"../core/EventBus\";\nimport { Trap } from \"../components/Trap\";\n\nexport class RenderSystem {\n    constructor(private em: EntityManager,\n        private prefabs: Record<PrefabType, Prefab>,\n        private gameRoot: Node,\n        private tilesLayer: Node,\n        private entityLayer: Node,\n        private playerLayer: Node,\n        private tileSize: number = 64,\n        private stepDuration: number = 0.15\n    ) {\n        eventBus.on('movePath', this.onMovePath.bind(this));\n    }\n\n    getPrefabName(entityId: number): PrefabType | null {\n        if (this.em.hasComponent(entityId, PlayerTag)) return PrefabNames.Player;\n        if (this.em.hasComponent(entityId, EnemyTag)) return PrefabNames.Enemy;\n        if (this.em.hasComponent(entityId, TileTag)) return PrefabNames.Tile;\n        return null;\n    }\n\n    render() {\n        const entities = this.em.getEntityWithComponent(Position);\n\n        for (const id of entities) {\n            const prefabName = this.getPrefabName(id);\n            if (!prefabName) continue;\n            const position = this.em.getComponent(id, Position);\n            if (!position) continue;\n\n            let view = this.em.getComponent(id, ViewComponent);\n            if (!view) {\n                console.log(prefabName);\n                view = new ViewComponent(prefabName);\n                this.em.addComponent(id, view, ViewComponent);\n\n                const prefab = this.prefabs[prefabName];\n                const node = instantiate(prefab);\n                node.setPosition(new Vec3(position.x * this.tileSize, position.y * this.tileSize, 0));\n\n                if (prefabName === PrefabNames.Tile)\n                    node.on(Node.EventType.TOUCH_END, () => {\n                        SceneController._instance?.onTileTapped(position);\n                    });\n\n                if (prefabName === PrefabNames.Player)\n                    this.playerLayer.addChild(node);\n                else if (prefabName === PrefabNames.Tile)\n                    this.tilesLayer.addChild(node);\n                else if (prefabName === PrefabNames.Enemy)\n                    this.entityLayer.addChild(node);\n\n                view.node = node;\n            }\n        }\n    }\n\n    /*private onMovePath(payload: { entity: number; path: Position[] }) {\n        const { entity, path } = payload;\n        const viewComp = this.em.getComponent(entity, ViewComponent);\n        if (!viewComp?.node) return;\n\n        const node = viewComp.node;\n        const z = node.getPosition().z;\n\n        // Начинаем chain tween-а\n        let seq = tween(node);\n\n        path.forEach((step, idx) => {\n            const targetPos = new Vec3(\n                step.x * this.tileSize,\n                step.y * this.tileSize,\n                z\n            );\n\n            seq = seq\n                .to(this.stepDuration, { position: targetPos })\n                .call(() => {\n                    // На каждом шаге сразу обновляем ECS-Position\n                    const pos = this.em.getComponent(entity, Position);\n                    if (pos) {\n                        pos.x = step.x;\n                        pos.y = step.y;\n                    }\n                    // Если последний шаг — сообщаем о завершении\n                    if (idx === path.length - 1) {\n                        eventBus.emit(\"moveComplete\", { entity });\n                    }\n                });\n        });\n\n        seq.start();\n    }*/\n\n    /*private onMovePath({ entity, path }: { entity: number; path: Position[] }) {\n        const view = this.em.getComponent(entity, ViewComponent);\n        if (!view?.node) return;\n\n        const node = view.node;\n        const z = node.getPosition().z;\n\n        // рекурсивная функция для по-шаговой анимации\n        const animateStep = (idx: number) => {\n            if (idx >= path.length) {\n                // закончили путь без попадания в ловушку\n                eventBus.emit('moveComplete', { entity });\n                return;\n            }\n            const step = path[idx];\n            const target = new Vec3(\n                step.x * this.tileSize,\n                step.y * this.tileSize,\n                z\n            );\n\n            tween(node)\n                .to(this.stepDuration, { position: target })\n                .call(() => {\n                    // 1) Синхронизируем ECS-Position\n                    const pos = this.em.getComponent(entity, Position)!;\n                    pos.x = step.x;\n                    pos.y = step.y;\n\n                    // 2) Проверяем ловушки на этой клетке\n                    const trapIds = this.em.getEntityWithComponent(Trap)\n                        .filter(tid => {\n                            const p = this.em.getComponent(tid, Position)!;\n                            return p.x === step.x && p.y === step.y;\n                        });\n                    if (trapIds.length > 0) {\n                        // берём первую ловушку, останавливаем движение\n                        const trapId = trapIds[0];\n                        eventBus.emit('trapTriggered', { entity, trap: trapId });\n                        return;\n                    }\n\n                    // 3) Идём к следующему шагу\n                    animateStep(idx + 1);\n                })\n                .start();\n        };\n\n        // стартуем с первого шага\n        animateStep(0);\n    }*/\n\n    private onMovePath({ entity, path }: { entity: number; path: Position[] }) {\n        const view = this.em.getComponent(entity, ViewComponent);\n        if (!view?.node || path.length === 0) return;\n\n        const node = view.node;\n        const z = node.getPosition().z;\n\n        const animateStep = (idx: number) => {\n            if (idx >= path.length) {\n                // 1) Закончили движение\n                eventBus.emit('moveComplete', { entity });\n\n                // 2) Проверяем, есть ли враг на той же клетке\n                const pos = this.em.getComponent(entity, Position)!;\n                const enemies = this.em.getEntityWithComponent(EnemyTag)\n                    .filter(eid => {\n                        const p = this.em.getComponent(eid, Position)!;\n                        return p.x === pos.x && p.y === pos.y;\n                    });\n                if (enemies.length > 0) {\n                    // Первый враг — цель атаки\n                    eventBus.emit('attackStart', {\n                        attacker: entity,\n                        target: enemies[0]\n                    });\n                }\n                return;\n            }\n\n            const step = path[idx];\n            const target = new Vec3(\n                step.x * this.tileSize,\n                step.y * this.tileSize,\n                z\n            );\n\n            tween(node)\n                .to(this.stepDuration, { position: target })\n                .call(() => {\n                    // а) Синхронизируем логику\n                    const pos = this.em.getComponent(entity, Position)!;\n                    pos.x = step.x;\n                    pos.y = step.y;\n\n                    // б) Проверяем ловушки\n                    const trapIds = this.em.getEntityWithComponent(Trap)\n                        .filter(tid => {\n                            const p = this.em.getComponent(tid, Position)!;\n                            return p.x === step.x && p.y === step.y;\n                        });\n                    if (trapIds.length > 0) {\n                        eventBus.emit('trapTriggered', {\n                            entity,\n                            trap: trapIds[0]\n                        });\n                        return;\n                    }\n\n                    // в) Идём к следующему шагу\n                    animateStep(idx + 1);\n                })\n                .start();\n        };\n\n        animateStep(0);\n    }\n\n    update(dt: number) {\n\n    }\n}\n\n"]}