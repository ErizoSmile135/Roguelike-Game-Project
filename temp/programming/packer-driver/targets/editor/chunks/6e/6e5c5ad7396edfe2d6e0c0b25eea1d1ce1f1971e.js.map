{"version":3,"sources":["file:///C:/GameECSProject/assets/scripts/core/EventBus.ts"],"names":["EventBus","listeners","on","event","fn","Set","add","off","delete","emit","payload","forEach","eventBus"],"mappings":";;;8BAsDaA,Q;;;;;;;;;;;;;;;;;;;0BAAAA,Q,GAAN,MAAMA,QAAN,CAAe;AAAA;AAAA,eAGZC,SAHY,GAG+B,EAH/B;AAAA;;AAKpB;AACF;AACA;AACA;AACA;AACSC,QAAAA,EAAE,CACPC,KADO,EAEPC,EAFO,EAGD;AACN;AACA,cAAI,CAAC,KAAKH,SAAL,CAAeE,KAAf,CAAL,EAA4B;AAC1B,iBAAKF,SAAL,CAAeE,KAAf,IAAwB,IAAIE,GAAJ,EAAxB;AACD;;AACD,eAAKJ,SAAL,CAAeE,KAAf,EAAuBG,GAAvB,CAA2BF,EAA3B;AACD;AAED;AACF;AACA;;;AACSG,QAAAA,GAAG,CACRJ,KADQ,EAERC,EAFQ,EAGF;AAAA;;AACN,wCAAKH,SAAL,CAAeE,KAAf,4CAAuBK,MAAvB,CAA8BJ,EAA9B;AACD;AAED;AACF;AACA;;;AACSK,QAAAA,IAAI,CACTN,KADS,EAETO,OAFS,EAGH;AAAA;;AACN,yCAAKT,SAAL,CAAeE,KAAf,6CAAuBQ,OAAvB,CAAgCP,EAAD,IAC7B;AACCA,UAAAA,EAAD,CAAiCM,OAAjC,CAFF;AAID;;AA1CmB,O,GA6CtB;;;0BACaE,Q,GAAW,IAAIZ,QAAJ,E","sourcesContent":["/*import { Position } from \"../components/Position\";\r\n\r\nexport interface EventMap {\r\n  movePath:         { entity: number; path: Position[] };\r\n  moveComplete:     { entity: number };\r\n  trapTriggered:  { entity: number; trap: number; damage: number };\r\n}\r\n\r\nexport class EventBus {\r\n  private listeners: {\r\n    [E in keyof EventMap]?: Set<(payload: EventMap[E]) => void>\r\n  } = {};\r\n\r\n  // Подписка\r\n  public on<E extends keyof EventMap>(\r\n    event: E,\r\n    fn: (payload: EventMap[E]) => void\r\n  ) {\r\n    if (!this.listeners[event]) {\r\n      this.listeners[event] = new Set();\r\n    }\r\n    this.listeners[event]!.add(fn);\r\n  }\r\n\r\n  // Отписка\r\n  public off<E extends keyof EventMap>(\r\n    event: E,\r\n    fn: (payload: EventMap[E]) => void\r\n  ) {\r\n    this.listeners[event]?.delete(fn);\r\n  }\r\n\r\n  // Испускание\r\n  public emit<E extends keyof EventMap>(\r\n    event: E,\r\n    payload: EventMap[E]\r\n  ) {\r\n    this.listeners[event]?.forEach(fn => fn(payload));\r\n  }\r\n}\r\n\r\nexport const eventBus = new EventBus();*/\r\n\r\nimport { Position } from '../components/Position';\r\n\r\nexport interface EventMap {\r\n  movePath:       { entity: number; path: Position[] };\r\n  moveComplete:   { entity: number };\r\n  trapTriggered:  { entity: number; trap: number };\r\n  attackStart:    { attacker: number; target: number };\r\n}\r\n\r\nexport type EventKey = keyof EventMap;\r\n\r\nexport class EventBus {\r\n  // Храним слушателей в виде map<string, Set<Function>>\r\n  // — в рантайме все подписчики лежат здесь, а типовую проверку мы делаем в on()/emit()\r\n  private listeners: Record<string, Set<Function>> = {};\r\n\r\n  /**\r\n   * Подписка на событие.\r\n   * E — конкретный ключ из EventMap.\r\n   * fn — функция, принимающая правильный payload.\r\n   */\r\n  public on<E extends EventKey>(\r\n    event: E,\r\n    fn: (payload: EventMap[E]) => void\r\n  ): void {\r\n    // создаём Set<Function> при первой подписке\r\n    if (!this.listeners[event]) {\r\n      this.listeners[event] = new Set();\r\n    }\r\n    this.listeners[event]!.add(fn);\r\n  }\r\n\r\n  /**\r\n   * Отписка от события.\r\n   */\r\n  public off<E extends EventKey>(\r\n    event: E,\r\n    fn: (payload: EventMap[E]) => void\r\n  ): void {\r\n    this.listeners[event]?.delete(fn as Function);\r\n  }\r\n\r\n  /**\r\n   * Эмит события.\r\n   */\r\n  public emit<E extends EventKey>(\r\n    event: E,\r\n    payload: EventMap[E]\r\n  ): void {\r\n    this.listeners[event]?.forEach((fn) =>\r\n      // приводим к нужному типу\r\n      (fn as (p: EventMap[E]) => void)(payload)\r\n    );\r\n  }\r\n}\r\n\r\n// глобальный экспорт\r\nexport const eventBus = new EventBus();\r\n\r\n\r\n"]}