{"version":3,"sources":["file:///C:/GameECSProject/assets/scripts/systems/RenderSystem.ts"],"names":["RenderSystem","instantiate","Vec3","Node","tween","PlayerTag","PrefabNames","EnemyTag","TileTag","Position","ViewComponent","SceneController","eventBus","constructor","em","prefabs","gameRoot","tilesLayer","entityLayer","playerLayer","tileSize","stepDuration","on","onMovePath","bind","getPrefabName","entityId","hasComponent","Player","Enemy","Tile","render","entities","getEntityWithComponent","id","prefabName","position","getComponent","view","console","log","addComponent","prefab","node","setPosition","x","y","EventType","TOUCH_END","_instance","onTileTapped","addChild","update","dt","payload","entity","path","viewComp","z","getPosition","seq","forEach","step","idx","targetPos","to","call","pos","length","emit","start"],"mappings":"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","sourcesContent":["import { instantiate, Prefab, Vec3, Node, UITransform, tween } from \"cc\";\nimport { EntityManager } from \"../core/EntityManager\";\nimport { PlayerTag } from \"../components/Tag/PlayerTag\";\nimport { PrefabNames } from \"../data/consts\";\nimport { EnemyTag } from \"../components/Tag/EnemyTag\";\nimport { TileTag } from \"../components/Tag/TileTag\";\nimport { Position } from \"../components/Position\";\nimport { ViewComponent } from \"../components/core/ViewComponent\";\nimport { SceneController } from \"../core/SceneController\";\nimport { PrefabType } from \"../data/types\";\nimport { eventBus } from \"../core/EventBus\";\n\nexport class RenderSystem {\n    constructor(private em: EntityManager,\n        private prefabs: Record<PrefabType, Prefab>,\n        private gameRoot: Node,\n        private tilesLayer: Node,\n        private entityLayer: Node,\n        private playerLayer: Node,\n        private tileSize: number = 64,\n        private stepDuration: number = 0.15\n    ) {\n        /*eventBus.on(\"positionChanged\", ({ entity, newPos }) => {\n            const view = this.entityManager.getComponent(entity, ViewComponent);\n            if (view?.node) {\n                view.node.setPosition(\n                    new Vec3(newPos.x * this.tileSize, newPos.y * this.tileSize, 0)\n                );\n            }\n            const pos = this.entityManager.getComponent(entity, Position);\n            if (pos) {\n                pos.x = newPos.x;\n                pos.y = newPos.y;\n            }\n        });*/\n        eventBus.on('movePath', this.onMovePath.bind(this));\n    }\n\n    getPrefabName(entityId: number): PrefabType | null {\n        if (this.em.hasComponent(entityId, PlayerTag)) return PrefabNames.Player;\n        if (this.em.hasComponent(entityId, EnemyTag)) return PrefabNames.Enemy;\n        if (this.em.hasComponent(entityId, TileTag)) return PrefabNames.Tile;\n        return null;\n    }\n\n    render() {\n        const entities = this.em.getEntityWithComponent(Position);\n\n        for (const id of entities) {\n            const prefabName = this.getPrefabName(id);\n            if (!prefabName) continue;\n            const position = this.em.getComponent(id, Position);\n            if (!position) continue;\n\n            let view = this.em.getComponent(id, ViewComponent);\n            if (!view) {\n                console.log(prefabName);\n                view = new ViewComponent(prefabName);\n                this.em.addComponent(id, view, ViewComponent);\n\n                const prefab = this.prefabs[prefabName];\n                const node = instantiate(prefab);\n                node.setPosition(new Vec3(position.x * this.tileSize, position.y * this.tileSize, 0));\n\n                /*if (prefabName === 'Tile') node.getComponent(UITransform).priority = 0;\n                else if (prefabName === 'Enemy') node.getComponent(UITransform).priority = 1;\n                else if (prefabName === 'Player') node.getComponent(UITransform).priority = 2;*/\n                //node.setSiblingIndex(this.gameRoot.children.length - 1);\n\n                /*switch (prefabName) {\n                    case PrefabNames.Tile:\n                        node.setSiblingIndex(0);\n                        break;\n                    case PrefabNames.Enemy:\n                        node.setSiblingIndex(1);\n                        break;\n                    case PrefabNames.Player:\n                        node.setSiblingIndex(entities.length - 1);\n                        break;\n                }*/\n\n                if (prefabName === PrefabNames.Tile)\n                    node.on(Node.EventType.TOUCH_END, () => {\n                        SceneController._instance?.onTileTapped(position);\n                    });\n\n                if (prefabName === PrefabNames.Player)\n                    this.playerLayer.addChild(node);\n                else if (prefabName === PrefabNames.Tile)\n                    this.tilesLayer.addChild(node);\n                else if (prefabName === PrefabNames.Enemy)\n                    this.entityLayer.addChild(node);\n\n                view.node = node;\n\n                //console.log('add ' + prefabName + position.x + position.y)\n                //console.log(\"Added node\", node.name, \"at\", node.getPosition());\n                //console.log(node.isValid, node.activeInHierarchy, node.getWorldPosition());\n            }\n        }\n    }\n\n    update(dt: number) {\n        /*const entities = this.entityManager.getEntityWithComponent(ViewComponent);\n        for (const id of entities) {\n            const view = this.entityManager.getComponent(id, ViewComponent);\n            const pos  = this.entityManager.getComponent(id, Position);\n            if (view?.node && pos) {\n                view.node.setPosition(\n                    new Vec3(pos.x * this.tileSize, pos.y * this.tileSize, view.node.getPosition().z)\n                );\n            }\n        }*/\n    }\n\n    /*function inputFromVec2(entity: number, type: string, vec: Vec2) {\n        return new InputComponent(entity, type as any, vec.x, vec.y);\n    }*/\n\n    /**\n    * Обработчик события, когда рассчитан путь.\n    * @param payload.entity — ID сущности, которой нужно двигать\n    * @param payload.path   — массив логических позиций по порядку\n    */\n    /*private onMovePath(payload: { entity: number; path: Position[] }) {\n        const { entity, path } = payload;\n        const viewComp = this.em.getComponent(entity, ViewComponent);\n        //const pos = this.em.getComponent(entity, Position);\n\n        // Если визуала нет или путь пуст — ничего не делаем\n        if (!viewComp?.node || path.length === 0) {\n            return;\n        }\n\n        const node = viewComp.node;\n        // Сохраняем Z, чтобы не уронить глубину слоя\n        const z = node.getPosition().z;\n\n        // Начинаем сборку цепочки анимаций\n        let seq = tween(node);\n\n        for (const step of path) {\n            // Вычисляем цель в мировых пикселях\n            const targetPos = new Vec3(\n                step.x * this.tileSize,\n                step.y * this.tileSize,\n                z\n            );\n\n            //pos.x = step.x;\n            //pos.y = step.y;\n\n            // Добавляем в цепочку tween, который за stepDuration секунд\n            // переместит node.position → targetPos\n            seq = seq.to(this.stepDuration, { position: targetPos });\n        }\n\n        // После того как пройдём весь путь — можем вызвать коллбэк\n        \n\n        // Запускаем всю собранную последовательность\n        seq.start();\n    }*/\n\n    private onMovePath(payload: { entity: number; path: Position[] }) {\n        const { entity, path } = payload;\n        const viewComp = this.em.getComponent(entity, ViewComponent);\n        if (!viewComp?.node) return;\n\n        const node = viewComp.node;\n        const z = node.getPosition().z;\n\n        // Начинаем chain tween-а\n        let seq = tween(node);\n\n        path.forEach((step, idx) => {\n            const targetPos = new Vec3(\n                step.x * this.tileSize,\n                step.y * this.tileSize,\n                z\n            );\n\n            seq = seq\n                .to(this.stepDuration, { position: targetPos })\n                .call(() => {\n                    // На каждом шаге сразу обновляем ECS-Position\n                    const pos = this.em.getComponent(entity, Position);\n                    if (pos) {\n                        pos.x = step.x;\n                        pos.y = step.y;\n                    }\n                    // Если последний шаг — сообщаем о завершении\n                    if (idx === path.length - 1) {\n                        eventBus.emit(\"moveComplete\", { entity });\n                    }\n                });\n        });\n\n        seq.start();\n    }\n\n}\n\n"]}